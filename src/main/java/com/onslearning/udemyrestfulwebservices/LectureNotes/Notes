**************************************************************************************************
                                        ONSJHJSA
**************************************************************************************************

==> Project structure for RESTful Webservices.

-> Create Spring Initializer project. Provide appropriate groupID, ArtifactID (all lower case).
-> Select "Web" in dependencies as it requires web dependencies to create Spring MVC and RESTful api project.

==> Create HelloWorld program:

-> To Run any program on Spring Boot, RestController is needed. RestController is front controller which takes care of all the
    web requests.
-> Create a package "Controller" -> Java class "Hello World".
For Eg:

        @RestController
        public class HelloWorld {

            @RequestMapping("/")
            public String getHelloWorld(){
                return "Hello World";
            }
        }

-> HelloWorld class should be annotated with "@RestController" annotation.
-> Method getHelloWorld return String "Hello World".

=> IMP: Method needs to map wit

    @RequestMapping("/") : Here "/" represent normal URL. web URL. To achieve this, Dev needs to use

    [
        In our case server start at port 8080. So our URL would be localhost:8080.
        In my machine, port 8080 is used by other application. We can switch different port in "resources -> application.properties"
        server.port=8084
    ]

==> Type: localhost:8084 will return Hello World.

==> Dev can map URI (string at the end URL) for different requests. Dev used "/api" in @RequestMapping annotation.

        @RequestMapping("/api")
        public String getString(){
            return "Use of URI - api";
        }

        localhost:8084/api : will return "Use of URI - api";

===========================================================================================================================

Create UserController.

--> @RequestMapping can be defined at the class level afetr @RestController.

    @RestController
    @RequestMapping("users")        // localhost:8084/users
    public class UserController {
    }

-> Here, Class level @RequestMapping("users") is defined. All the URLs will be localhost:8084/users

        @RequestMapping(method = RequestMethod.GET,value = "/getUser")
        public String getUser(){
            return "Get user method is called.";
        }

=> Method getUser is creted. Annotation "@RequestMapping(method = RequestMethod.GET)" define this is GET request ( ~ Read ).
    Value = "/getUser" is providing specific URI to access this method.

    http://localhost:8084/users/getUser : This URL will return "Get user method is called."

==> Simillar annotation for GETMapping :

      // @RequestMapping(method = RequestMethod.GET,value = "/getUser")

         @GetMapping(value = "/getU")
         public String getUser(){
             return "Get user method is called.";
         }

===> FOUR MAIN REQUEST MAPPING METHODS:

    GET     :    Read operation.
    POST    :    Create Operation.
    PUT     :    Update Operation
    DELETE  :    Delete operation.

======================================================================================================================================================
======================================================================================================================================================

THERE ARE TWO WAYS TO TEST API / CHECK THE API RESULT:

1. Paste API in Browser i.e Chrome. firefox etc.
2. USE POSTMAN tool.

--> Postman is the free application in which Dev can paste URL and check the result.
--> Even, Dev can pass parameters in the URL. Response can be seen as a plain text, JSON OR XML format.

======================================================================================================================================================
======================================================================================================================================================

        @PathVariable:

--> To receive information of the specific user with ID = 1, userID needs to pass in URL.
--> Fetch the value of userID passing in the URL by using @PathVariable annotation.

For Eg:
            @GetMapping(value = "/{userID}")
            public String getUserByID(@PathVariable String userID){
                return "The user with the user ID = " + userID;
            }

--> Here, value = "/{userID}" fetch the userID from the URL. So URL must be: "localhost:8084/users/1"
    Dev provided userID within the URL, That userID can be use by @PathVariable and provide userID in the argument.

======================================================================================================================================================
======================================================================================================================================================
** DIFFERENCE BETWEEN URI AND STRING PARAMETER:

   localhost:8084/users?page=1&limit=10;

-> Above URL, anything after URL "/.." is called URI and anything after "?" is string parameter.

      URL: localhost:8084
      URI: /users
      String Param: page=1 & limit=10

--> When user pass URI, Dev can fetch that using @PathVariable annotation. (For Eg. localhost:8084/users/1 => where 1 is userID fetch by @PathVariable)

--> When user pass String Param, Dev can fetch them using "@RequestParam" annotation.

     @GetMapping             //http://localhost:8084/users?page=1&limit=40
        public String getUserByPage(@RequestParam(value = "page") int page, @RequestParam(value = "limit") int limit){
            return "User on the page = "+ page + " with limit = " + limit;
        }

--> Here, URL passed is "http://localhost:8084/users?page=1&limit=40" with param page=1 and limit=40.
    Annotation:  @RequestParam(value="page") fetch page number and pass as an argument.
                 @RequestParam(value="limit") fetch limit annotation.

                 RequestParam value should match the string param passed in the URL.

****  REQUIRED AND OPTIONAL PARAMETERS:

    Here, page and limit are required parameter. Dev can make this parameter optional as well.
    Dev can use required = false in the @requestParam (value="name", required= false) to make them optional.

    @GetMapping(value = "/optParam")                    //http://localhost:8084/users/optParam?name=Sagar&city=Denver
        public String getUserOptionalParam(@RequestParam(value = "name", required = false) String name, @RequestParam(value = "city", required = false) String city){
            return "Optional Param Name = " + name + " city = " + city;
        }

 URL    :   http://localhost:8084/users/optParam?name=Sagar&city=Denver
 Outout :   Optional Param Name = Sagar city = Denver.

 ** MIMP : In case of Optional Param, when user does not provide param then null should pass.

  URL    :   http://localhost:8084/users/optParam
  Outout :   Optional Param Name = null city = null.

==> But if int parameter is blank such as page & limit then User will get an error as empty int can not convert to null.

======================================================================================================================================================
======================================================================================================================================================

**** RETURNING JAVA OBJECT AS A RETURN VALUE:

--> First create a "User class" with private attributes id, name, age and salary. Generate Getters & Setters, Constuctor and toString method.

=> Dev wants to return object of the class User when user pass userID in URI.
For eg:

    @GetMapping(value = "/{userID}")        //http://localhost:8084/users/1
        public User getUserByID(@PathVariable String userID){
            User aUser = new User(Integer.parseInt(userID),"Sam", 25, 1000);
            return aUser;
        }

==> URL: http://localhost:8084/users/2
Output : {
             "userID": 2,
             "userName": "Sam",
             "age": 25,
             "salary": 1000
         }

==> User can get URL response in JSON OR XML format. Steps to implement the response in XML format.

1. In Postman, go to Headers tab. In Key column select "Content type" and value column "application/xml"
2. In the @GetMappingAnnotation, need to define produces and MediaType. Here, I mentioned both XML and JSON file format.

    @GetMapping(value = "/{userID}", produces = {MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION.JSON.VALUE})

3. I still face an error as I need to provide Maven dependency of "JSON Dataformat XML".

======================================================================================================================================================
======================================================================================================================================================

**** HTTP STATUS CODE:

    1XX     :       Informational
    2XX     :       Success
    3XX     :       Redirection
    4XX     :       Client Error
    5XX     :       Server Error

-> Below example illustrate ResponseEntity<> which return Java object as a Body and HTTPStatus code.

        @GetMapping(value = "/response/{uId}")
        public ResponseEntity<User> getUserResponse(@PathVariable(value = "uId") String uID){
            User userObject = new User(Integer.parseInt(uID), "Sagar",25, 2000);
            ResponseEntity<User> responseEntityUser = new ResponseEntity<User>(userObject, HttpStatus.OK);

            return responseEntityUser;
        }

-> ResponseEntity<> has two args. First is Body - provide object of the class. Second - HTTP Status.
-> HTTP status could be OK(200), BadGateway(500), BadRequest(400) ect.

======================================================================================================================================================
======================================================================================================================================================

**** HTTP POST METHOD:

-> Post method is similar to Create operation.
-> Generally, User fill out an online form OR sign up.
    During this operation, user provide name, email address, pwd.
-> This information passed in "JSON Payload" format.
-> Now, I need to convert JSON Payload into JAVA object to store that information.

=> JSON Payload EX / format:

    {
        "firstName" : "Sagar",
        "lastName" : "Bhatt",
        "email" : "sam@learning.com",
        "age" : 25,
    }

==> IMP STEPS FOR POST MAPPING:
1. @PostMapping annotation. [Alternative: @RequestMapping(method= RequestMethod.POST)]
2. Data coming from Web is in JSON PAYLOAD format.I Need to that consume data is in JSON
    format. This can be done as:
    @PostMapping(
                consumes = { MediaType = Application_JSON_Value }
                )
3. Method is returning object of class UserDetailModelReques using
    ResponseEntity(object, HttpStatus.OK). I need to mention that data created
    is in JSON format. This can be achieved by using "produced" attribute.

    @PostMapping(
            consumes = { MediaType = Application_XML_Value },
            produces = { MediaType = Application_JSON_Value }
                )

=> [Similar way, MediaType = Application_XML_Value is used for XML type data generate or receive.]

4. IMP: I need to convert JSON payload into JAVA object. To do that, I need to create a class
        "UserDetailModelRequest". private field name should match the Json Payload.

        JSON Payload:
        {
            "firstName" : "Sagar",
            "lastName" : "Bhatt",
            "email" : "A@b.com",
            "age" : "25"
        }

        public class UserDetailModelRequest {
            //Private field name should match the JSON Payload Entity Name ex. "firstName", "lastName", "email", "age".
            private String firstName;
            private String lastName;
            private String email;
            private String age;

5. @RequestBody annotation is used to map JSON Payload with Object of class.

    @PostMapping
    public ResponseEntity<UserDetailModelRequest> creatUser(@RequestBody UserDetailModelRequest userObjectFromURL)

6. Use getter method to get the object value which is JSON payload mapped value.

    UserDetailModelRequest userObject = new UserDetailModelRequest();
    userObject.setFirstName(userObjectFromURL.getFirstName());
    userObject.setLastName(userObjectFromURL.getLastName());
    userObject.setEmail(userObjectFromURL.getEmail());
    userObject.setAge(userObjectFromURL.getAge());

7. I use @RequestMapping<> to return object of UserDetailModelRequest class and HttpStatus.OK

======================================================================================================================================================
======================================================================================================================================================

**** Validating User data input / JSON Payload value for POST Mapping operation.

[
    i. I have created a new class with fname, lastname, email and password private field.
    ii. I am validating, those fields for proper email address, password field ect.

    Reference Link for Hibernate Bean Validation: https://howtodoinjava.com/hibernate/hibernate-validator-java-bean-validation/
]

1. First, Use @Valid annotation inside the method argument to enable data validation.

    public ResponseEntity<UserDataValidation> userValidate(@Valid @RequestBody UserDataValidation validationObject)

2. In Entity class use below Bean Validation Annotation.
    @NotNull    : Verify if the value is null.
    @NotEmpty   : Check whether value is empty.
    @Email      : Verify character sequence is valid email address or not.
    @Size(min=,
    max=)       : verify the length of character sequence. Eg: Password length must be between 8 - 20.

3. In each annotation, I can provide error message in case of validation fails.
    @Email(message="Please enter valid email address")
    @Size(min=8,max=16,message="Please enter between 8 -16 characters")

4. Create a method with @PostMapping. I put three attributes inside @PostMapping method.
    i. value = "/validate"      : http://localhost:8084/users/validate - URL Mapped with this method.
    ii. consumes    : Specify which format of information this method can consume. MediaType JSON or XML value.

        consumes = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE}

    iii. produces   : specify which format of information this method produces data.

        produces = { MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_VALUE }

5. @RequestBody annotation to Map Jason Payload with UserDataValidation class object.

         public ResponseEntity<UserDataValidation> userValidate(@Valid @RequestBody UserDataValidation validationObject)

6. @ResponseEntity(Body, HttpStatus) : Body - pass object of the class. HttpStatus - Ok (200), Bad Request(400), Bad Gateway(500)

===============================================================================================
**** MIMP :

1. When sending JSON Payload. Justify below two key,value pair in Header of Request Body.

         Accept  : application/json
    Content-Type : application/json

======================================================================================================================================================
======================================================================================================================================================

**** Create USER via @PostMapping, STORE in MAP and GET user details by providing USERID via @GetMapping:






